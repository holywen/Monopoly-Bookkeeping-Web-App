<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Monopoly Bookkeeping</title>
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#1976d2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Monopoly">
    <link rel="apple-touch-icon" href="icon-192.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #1976d2;
            --secondary-color: #424242;
            --success-color: #4caf50;
            --error-color: #f44336;
            --warning-color: #ff9800;
            --background: #f5f5f5;
            --surface: #ffffff;
            --text-primary: #212121;
            --text-secondary: #757575;
            --border-radius: 12px;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
            --transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 480px;
            margin: 0 auto;
            padding: 16px;
            min-height: 100vh;
        }

        header {
            background: var(--surface);
            padding: 16px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 16px;
            text-align: center;
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 8px;
        }

        .offline-indicator {
            display: none;
            background: var(--warning-color);
            color: white;
            padding: 8px;
            border-radius: var(--border-radius);
            text-align: center;
            margin-bottom: 16px;
            font-size: 14px;
        }

        .offline-indicator.show {
            display: block;
        }

        .screen {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: var(--border-radius);
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            min-height: 44px;
            min-width: 44px;
            width: 100%;
            margin-bottom: 12px;
        }

        .btn:hover {
            background: #1565c0;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--secondary-color);
        }

        .btn-secondary:hover {
            background: #353535;
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-error {
            background: var(--error-color);
        }

        .card {
            background: var(--surface);
            padding: 16px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 16px;
        }

        .player-setup {
            margin-bottom: 16px;
        }

        .token-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin: 16px 0;
        }

        .token-option {
            aspect-ratio: 1;
            border: 2px solid #e0e0e0;
            border-radius: var(--border-radius);
            background: var(--surface);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            position: relative;
        }

        .token-option:hover {
            border-color: var(--primary-color);
            transform: scale(1.05);
        }

        .token-option.selected {
            border-color: var(--primary-color);
            background: rgba(25, 118, 210, 0.1);
        }

        .token-option.selected::after {
            content: '‚úì';
            position: absolute;
            top: 4px;
            right: 4px;
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .token-svg {
            width: 48px;
            height: 48px;
        }

        .input-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            margin-bottom: 4px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 14px;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: var(--transition);
            background: var(--surface);
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .player-list {
            margin-bottom: 16px;
        }

        .player-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background: var(--surface);
            border-radius: var(--border-radius);
            margin-bottom: 8px;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .player-item:hover {
            transform: translateX(4px);
        }

        .player-item button {
            margin-left: 8px;
        }

        .delete-player-btn {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: var(--error-color);
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            line-height: 1;
            min-height: auto;
        }

        .delete-player-btn:hover {
            color: #d32f2f;
            transform: scale(1.1);
        }

        .player-token {
            width: 32px;
            height: 32px;
            margin-right: 12px;
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .player-balance {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .balance-positive {
            color: var(--success-color);
        }

        .balance-negative {
            color: var(--error-color);
        }

        .transaction-form {
            margin-bottom: 16px;
        }

        .transaction-type-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .type-btn {
            padding: 8px;
            border: 2px solid #e0e0e0;
            background: var(--surface);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            font-size: 12px;
            text-align: center;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .type-btn:hover {
            border-color: var(--primary-color);
        }

        .type-btn.active {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
        }

        .history-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            padding: 12px;
            background: var(--surface);
            border-radius: var(--border-radius);
            margin-bottom: 8px;
            box-shadow: var(--shadow);
            font-size: 14px;
        }

        .history-time {
            color: var(--text-secondary);
            font-size: 12px;
            margin-bottom: 4px;
        }

        .nav-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 16px 0;
        }

        .nav-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: var(--transition);
        }

        .nav-dot.active {
            background: var(--primary-color);
            width: 24px;
            border-radius: 4px;
        }

        .swipe-hint {
            text-align: center;
            color: var(--text-secondary);
            font-size: 12px;
            margin-top: 16px;
        }

        @media (max-width: 480px) {
            .container {
                padding: 8px;
            }

            .card {
                padding: 12px;
            }

            h1 {
                font-size: 20px;
            }
        }

        .hidden {
            display: none !important;
        }

        /* Voice Control Styles */
        .voice-control {
            margin: 16px 0;
            padding: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: var(--border-radius);
            color: white;
        }

        .voice-btn {
            width: 100%;
            padding: 16px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: var(--border-radius);
            color: white;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .voice-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .voice-btn.listening {
            background: rgba(255, 255, 255, 0.4);
            border-color: #4caf50;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }

        .mic-icon {
            font-size: 20px;
        }

        .voice-result {
            margin-top: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .voice-commands {
            margin-top: 12px;
            font-size: 12px;
            opacity: 0.8;
        }

        .voice-commands h4 {
            margin-bottom: 4px;
        }

        .voice-commands ul {
            list-style: none;
            padding: 0;
        }

        .voice-commands li {
            margin-bottom: 2px;
        }

        /* Voice Confirmation Dialog */
        .voice-confirm-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .voice-confirm-content {
            background: var(--surface);
            padding: 24px;
            border-radius: var(--border-radius);
            max-width: 350px;
            width: 90%;
            text-align: center;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .voice-confirm-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .voice-confirm-text {
            font-size: 16px;
            margin-bottom: 20px;
            color: var(--text-secondary);
        }

        .voice-confirm-buttons {
            display: flex;
            gap: 12px;
        }

        .voice-confirm-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: var(--border-radius);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }

        .voice-confirm-btn.confirm {
            background: var(--success-color);
            color: white;
        }

        .voice-confirm-btn.cancel {
            background: var(--secondary-color);
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé© Monopoly Bookkeeping</h1>
            <p style="color: var(--text-secondary); font-size: 14px;">Track your game finances</p>
        </header>

        <div class="offline-indicator" id="offlineIndicator">
            üì± Offline Mode - All changes saved locally
        </div>

        <!-- Screen 1: Player Setup -->
        <div class="screen active" id="screen1">
            <div class="card">
                <h2 style="margin-bottom: 16px;">Add Players</h2>

                <div class="player-setup">
                    <div class="input-group">
                        <label for="playerName">Player Name</label>
                        <input type="text" id="playerName" placeholder="Enter player name" maxlength="20">
                    </div>

                    <div class="input-group">
                        <label>Select Token</label>
                        <div class="token-grid" id="tokenGrid">
                            <!-- Tokens will be populated by JavaScript -->
                        </div>
                    </div>

                    <div class="input-group">
                        <label>Starting Balance ($)</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="number" id="initialBalance" value="15" min="0" step="1" style="flex: 1;">
                            <select id="initialBalanceUnit" style="flex: 0 0 80px;">
                                <option value="M" selected>M</option>
                                <option value="K">K</option>
                            </select>
                        </div>
                    </div>

                    <button class="btn" id="addPlayerBtn">Add Player</button>
                </div>

                <div class="player-list" id="playerList">
                    <h3 style="margin-bottom: 12px;">Players</h3>
                    <div id="playersContainer">
                        <!-- Players will be listed here -->
                    </div>
                </div>

                <div style="display: flex; gap: 12px; margin-top: 16px;">
                    <button class="btn btn-success" id="startGameBtn" style="display: none; flex: 1;">Start Game</button>
                    <button class="btn btn-error" id="resetPlayersBtn" style="display: block; flex: 1;">Reset Players</button>
                </div>
            </div>
        </div>

        <!-- Screen 2: Transaction -->
        <div class="screen" id="screen2">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h2 style="margin: 0;">Game Actions</h2>
                    <div>
                        <button class="btn btn-secondary" onclick="game.restartGame()" style="margin-right: 8px; padding: 8px 16px; font-size: 14px;">Restart Game</button>
                        <button class="btn btn-error" onclick="game.endGame()" style="padding: 8px 16px; font-size: 14px;">End Game</button>
                    </div>
                </div>

                <div class="transaction-form">
                    <div class="transaction-type-selector">
                        <button class="type-btn active" data-type="one-to-one">1‚Üí1</button>
                        <button class="type-btn" data-type="one-to-many">1‚ÜíMany</button>
                        <button class="type-btn" data-type="many-to-one">Many‚Üí1</button>
                        <button class="type-btn" data-type="adjust">Adjust</button>
                    </div>

                    <div class="input-group" id="fromPlayerGroup">
                        <label for="fromPlayer">From/Player</label>
                        <select id="fromPlayer">
                            <option value="">Select player</option>
                        </select>
                    </div>

                    <div class="input-group" id="toPlayerGroup">
                        <label for="toPlayer">To</label>
                        <select id="toPlayer">
                            <option value="">Select player</option>
                        </select>
                    </div>

                    <div class="input-group" id="adjustPlayerGroup" style="display: none;">
                        <label for="adjustPlayer">Player to Adjust</label>
                        <select id="adjustPlayer">
                            <option value="">Select player</option>
                        </select>
                    </div>

                    <div class="input-group" id="toManyGroup" style="display: none;">
                        <label>Recipients (select multiple)</label>
                        <div id="toManyCheckboxes">
                            <!-- Checkboxes will be populated -->
                        </div>
                    </div>

                    <div class="input-group" id="fromManyGroup" style="display: none;">
                        <label>Payers (select multiple)</label>
                        <div id="fromManyCheckboxes">
                            <!-- Checkboxes will be populated -->
                        </div>
                    </div>

                    <div class="input-group" id="adjustTypeGroup" style="display: none;">
                        <label>Adjustment Type</label>
                        <select id="adjustType">
                            <option value="add">Add Money</option>
                            <option value="subtract">Subtract Money</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label>Amount ($)</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="number" id="amount" placeholder="0" min="0" step="1" style="flex: 1;">
                            <select id="amountUnit" style="flex: 0 0 80px;">
                                <option value="K" selected>K</option>
                                <option value="M">M</option>
                            </select>
                        </div>
                    </div>

                    <div class="input-group">
                        <label for="description">Description (optional)</label>
                        <input type="text" id="description" placeholder="e.g., Rent for Boardwalk">
                    </div>

                    <button class="btn btn-success" id="addTransactionBtn">Add Transaction</button>
                </div>
            </div>

            <div class="card">
                <h3 style="margin-bottom: 12px;">Current Balances</h3>
                <div id="currentBalances">
                    <!-- Balances will be displayed here -->
                </div>
            </div>

            <!-- Voice Control Panel -->
            <div class="card voice-control">
                <h3 style="margin-bottom: 12px;">üé§ ËØ≠Èü≥ÊéßÂà∂</h3>

                <!-- Language Mode Selection -->
                <div style="margin-bottom: 12px;">
                    <label style="color: rgba(255,255,255,0.8); font-size: 14px; margin-bottom: 4px; display: block;">ËØÜÂà´ËØ≠Ë®ÄÊ®°Âºè</label>
                    <select id="voiceLanguageMode" style="width: 100%; padding: 8px; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; background: rgba(255,255,255,0.1); color: white;">
                        <option value="zh-CN">‰∏≠Êñá‰ºòÂÖà (Êé®Ëçê)</option>
                        <option value="en-US">Ëã±Êñá‰ºòÂÖà</option>
                        <option value="auto">Ëá™Âä®Ê£ÄÊµã</option>
                    </select>
                </div>

                <!-- LLM Configuration -->
                <div style="margin-bottom: 12px;">
                    <label style="color: rgba(255,255,255,0.8); font-size: 14px; margin-bottom: 4px; display: block;">
                        ü§ñ AIÊô∫ËÉΩÁ∫†Èîô
                        <span id="llmStatus" style="font-size: 12px; margin-left: 8px; color: #ff9800;">‚óè Êú™ÈÖçÁΩÆ</span>
                    </label>

                    <!-- LLM Provider Selection -->
                    <select id="llmProvider" style="width: 100%; padding: 8px; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; background: rgba(255,255,255,0.1); color: white; margin-bottom: 8px;">
                        <option value="mock">Êú¨Âú∞Ê®°Êãü (Êó†ÈúÄAPI)</option>
                        <option value="openrouter">OpenRouter</option>
                        <option value="anthropic">Anthropic Claude</option>
                        <option value="openai">OpenAI</option>
                        <option value="nvidia">NVIDIA Build (NIM)</option>
                    </select>

                    <!-- API Key Input (hidden for mock mode) -->
                    <div id="apiKeySection" style="display: none;">
                        <input type="password" id="llmApiKey" placeholder="ËæìÂÖ•APIÂØÜÈí•" style="width: 100%; padding: 8px; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; background: rgba(255,255,255,0.1); color: white; margin-bottom: 8px;">
                        <button id="testLlmBtn" style="width: 100%; padding: 6px; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; background: rgba(255,255,255,0.2); color: white; font-size: 12px;">ÊµãËØïËøûÊé•</button>
                    </div>

                    <!-- Enable/Disable Toggle -->
                    <select id="llmCorrectionMode" style="width: 100%; padding: 8px; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; background: rgba(255,255,255,0.1); color: white; margin-top: 8px;">
                        <option value="enabled">ÂºÄÂêØÁ∫†Èîô</option>
                        <option value="disabled">ÂÖ≥Èó≠Á∫†Èîô</option>
                    </select>
                </div>

                <button id="voiceBtn" class="voice-btn">
                    <span class="mic-icon">üé§</span>
                    <span class="voice-text">Êåâ‰ΩèËØ¥ËØù</span>
                </button>
                <div id="voiceResult" class="voice-result">
                    <span style="color: rgba(255,255,255,0.6);">Êåâ‰ΩèÊåâÈíÆËØ¥Âá∫ËΩ¨Ë¥¶ÂëΩ‰ª§</span>
                </div>
                <div class="voice-commands">
                    <h4>ÊîØÊåÅÁöÑÂëΩ‰ª§Ôºö</h4>
                    <ul>
                        <li>‚Ä¢ "Áé©ÂÆ∂1ËΩ¨ÁªôÁé©ÂÆ∂2ÂçÅÂÖ≠‰∏á"</li>
                        <li>‚Ä¢ "ÁªôÁé©ÂÆ∂1Â¢ûÂä†‰∫îÂçÅ‰∏á"</li>
                        <li>‚Ä¢ "‰ªéÁé©ÂÆ∂2ÂáèÂ∞ë‰∫åÂçÅ‰∏á"</li>
                        <li>‚Ä¢ "EasonËΩ¨ÁªôHoly 100K"</li>
                        <li>‚Ä¢ "VivianËΩ¨ÁªôJustin 50K"</li>
                        <li>‚Ä¢ "ÁªôResinÂ¢ûÂä†200K"</li>
                        <li>‚Ä¢ "‰ªéEasonÂáèÂ∞ë100K"</li>
                        <li>‚Ä¢ "Eason transfer to Holy 100K" (Ëã±ÊñáÊ®°Âºè)</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Screen 3: History -->
        <div class="screen" id="screen3">
            <div class="card">
                <h2 style="margin-bottom: 16px;">Transaction History</h2>
                <div class="history-list" id="historyList">
                    <!-- Transaction history will be displayed here -->
                </div>
            </div>

            <div class="card">
                <h3 style="margin-bottom: 12px;">Game Settings</h3>
                <div class="input-group">
                    <label>Starting Balance ($)</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="number" id="newInitialBalance" value="15" min="0" step="1" style="flex: 1;">
                        <select id="newInitialBalanceUnit" style="flex: 0 0 80px;">
                            <option value="M" selected>M</option>
                            <option value="K">K</option>
                        </select>
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="game.setNewInitialBalance()">Set New Starting Balance</button>
            </div>

            <div class="card">
                <h3 style="margin-bottom: 12px;">Data Management</h3>
                <button class="btn btn-secondary" id="exportBtn">Export Data</button>
                <button class="btn btn-secondary" id="importBtn">Import Data</button>
                <button class="btn btn-error" id="resetBtn">Reset Complete Game</button>
                <input type="file" id="importFile" accept=".json" style="display: none;">
            </div>
        </div>

        <div class="nav-dots">
            <div class="nav-dot active" data-screen="1"></div>
            <div class="nav-dot" data-screen="2"></div>
            <div class="nav-dot" data-screen="3"></div>
        </div>

        <div class="swipe-hint">Swipe or tap dots to navigate</div>
    </div>

    <!-- Voice Confirmation Dialog -->
    <div id="voiceConfirmDialog" class="voice-confirm-dialog hidden">
        <div class="voice-confirm-content">
            <div class="voice-confirm-title">Á°ÆËÆ§ËØ≠Èü≥ÂëΩ‰ª§</div>
            <div class="voice-confirm-text" id="voiceConfirmText"></div>
            <div class="voice-confirm-buttons">
                <button id="voiceConfirmBtn" class="voice-confirm-btn confirm">Á°ÆËÆ§</button>
                <button id="voiceCancelBtn" class="voice-confirm-btn cancel">ÂèñÊ∂à</button>
            </div>
        </div>
    </div>

    <script>
        // Game State Management
        class MonopolyGame {
            constructor() {
                this.players = [];
                this.transactions = [];
                this.currentScreen = 1;
                this.transactionType = 'one-to-one';
                this.loadState();
                this.initializeTokens();
                this.bindEvents();
                this.updateUI();
                this.checkOnlineStatus();

                // Initialize voice control
                this.pendingVoiceCommand = null;
                this.initializeVoiceControl();

                // Initialize LLM integration
                this.setupLLMIntegration();
            }

            initializeTokens() {
                this.tokens = [
                    { id: 'hat', name: 'Top Hat', svg: '<svg viewBox="0 0 100 100" fill="#333"><rect x="20" y="40" width="60" height="30" rx="5"/><rect x="15" y="30" width="70" height="15" rx="3"/><rect x="35" y="20" width="30" height="15" rx="3"/><rect x="45" y="15" width="10" height="10"/></svg>' },
                    { id: 'car', name: 'Racecar', svg: '<svg viewBox="0 0 100 100" fill="#e74c3c"><rect x="20" y="50" width="60" height="20" rx="10"/><rect x="30" y="40" width="40" height="15" rx="5"/><circle cx="30" cy="70" r="8" fill="#333"/><circle cx="70" cy="70" r="8" fill="#333"/><rect x="50" y="45" width="15" height="10" fill="#87ceeb"/></svg>' },
                    { id: 'dog', name: 'Scottish Terrier', svg: '<svg viewBox="0 0 100 100" fill="#8b4513"><ellipse cx="50" cy="60" rx="25" ry="20"/><rect x="35" y="40" width="30" height="25" rx="10"/><circle cx="40" cy="35" r="8"/><circle cx="60" cy="35" r="8"/><rect x="25" y="55" width="15" height="25" rx="5"/><rect x="60" y="55" width="15" height="25" rx="5"/></svg>' },
                    { id: 'ship', name: 'Battleship', svg: '<svg viewBox="0 0 100 100" fill="#4682b4"><rect x="20" y="60" width="60" height="20" rx="3"/><rect x="30" y="40" width="40" height="25"/><rect x="45" y="25" width="10" height="20"/><polygon points="50,25 40,15 60,15"/></svg>' },
                    { id: 'iron', name: 'Flat Iron', svg: '<svg viewBox="0 0 100 100" fill="#708090"><path d="M30 40 L70 40 L70 70 L50 80 L30 70 Z"/><rect x="35" y="30" width="30" height="15" rx="3"/><circle cx="50" cy="25" r="5"/></svg>' },
                    { id: 'thimble', name: 'Thimble', svg: '<svg viewBox="0 0 100 100" fill="#c0c0c0"><path d="M40 30 L60 30 L65 70 L35 70 Z"/><ellipse cx="50" cy="30" rx="10" ry="5"/><circle cx="50" cy="20" r="3"/><rect x="45" y="15" width="10" height="8"/></svg>' }
                ];
                this.selectedToken = null;
                this.renderTokens();
            }

            renderTokens() {
                const tokenGrid = document.getElementById('tokenGrid');
                tokenGrid.innerHTML = this.tokens.map(token => `
                    <div class="token-option" data-token-id="${token.id}">
                        <div class="token-svg">${token.svg}</div>
                    </div>
                `).join('');

                // Add click handlers
                tokenGrid.querySelectorAll('.token-option').forEach(option => {
                    option.addEventListener('click', () => {
                        tokenGrid.querySelectorAll('.token-option').forEach(o => o.classList.remove('selected'));
                        option.classList.add('selected');
                        this.selectedToken = option.dataset.tokenId;
                    });
                });
            }

            bindEvents() {
                // Player management
                document.getElementById('addPlayerBtn').addEventListener('click', () => this.addPlayer());
                document.getElementById('startGameBtn').addEventListener('click', () => this.startGame());
                document.getElementById('resetPlayersBtn').addEventListener('click', () => this.resetPlayers());

                // Transaction management
                document.getElementById('addTransactionBtn').addEventListener('click', () => this.addTransaction());

                // Transaction type switching
                document.querySelectorAll('.type-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.transactionType = btn.dataset.type;
                        this.updateTransactionForm();
                    });
                });

                // Navigation
                document.querySelectorAll('.nav-dot').forEach(dot => {
                    dot.addEventListener('click', () => {
                        this.switchScreen(parseInt(dot.dataset.screen));
                    });
                });

                // Swipe navigation
                this.setupSwipeNavigation();

                // Data management
                document.getElementById('exportBtn').addEventListener('click', () => this.exportData());
                document.getElementById('importBtn').addEventListener('click', () => {
                    document.getElementById('importFile').click();
                });
                document.getElementById('importFile').addEventListener('change', (e) => this.importData(e));
                document.getElementById('resetBtn').addEventListener('click', () => this.resetGame());

                // Online/offline detection
                window.addEventListener('online', () => this.checkOnlineStatus());
                window.addEventListener('offline', () => this.checkOnlineStatus());

                // Unit change handlers for input validation
                this.setupUnitChangeHandlers();
            }

            setupUnitChangeHandlers() {
                // Function to update input step based on unit
                const updateInputStep = (inputId, unitSelectId) => {
                    const input = document.getElementById(inputId);
                    const unitSelect = document.getElementById(unitSelectId);
                    
                    const updateStep = () => {
                        const unit = unitSelect.value;
                        if (unit === 'M') {
                            input.step = '0.1';
                        } else {
                            input.step = '1';
                        }
                    };

                    // Initial update
                    updateStep();
                    
                    // Update on unit change
                    unitSelect.addEventListener('change', updateStep);
                };

                // Setup for all amount inputs
                updateInputStep('initialBalance', 'initialBalanceUnit');
                updateInputStep('amount', 'amountUnit');
                updateInputStep('newInitialBalance', 'newInitialBalanceUnit');
            }

            setupSwipeNavigation() {
                let touchStartX = 0;
                let touchEndX = 0;

                document.addEventListener('touchstart', (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                });

                document.addEventListener('touchend', (e) => {
                    touchEndX = e.changedTouches[0].screenX;
                    this.handleSwipe();
                });

                this.handleSwipe = () => {
                    const swipeThreshold = 50;
                    const diff = touchStartX - touchEndX;

                    if (Math.abs(diff) > swipeThreshold) {
                        if (diff > 0 && this.currentScreen < 3) {
                            this.switchScreen(this.currentScreen + 1);
                        } else if (diff < 0 && this.currentScreen > 1) {
                            this.switchScreen(this.currentScreen - 1);
                        }
                    }
                };
            }

            switchScreen(screenNumber) {
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.remove('active');
                });
                document.getElementById(`screen${screenNumber}`).classList.add('active');

                document.querySelectorAll('.nav-dot').forEach(dot => {
                    dot.classList.remove('active');
                    if (parseInt(dot.dataset.screen) === screenNumber) {
                        dot.classList.add('active');
                    }
                });

                this.currentScreen = screenNumber;
                this.updateUI();
            }

            addPlayer() {
                const nameInput = document.getElementById('playerName');
                const name = nameInput.value.trim();

                if (!name) {
                    alert('Please enter a player name');
                    return;
                }

                if (!this.selectedToken) {
                    alert('Please select a token');
                    return;
                }

                if (this.players.some(p => p.name === name)) {
                    alert('Player name already exists');
                    return;
                }

                const initialBalanceInput = document.getElementById('initialBalance');
                const initialBalanceUnitSelect = document.getElementById('initialBalanceUnit');
                const initialBalanceRaw = parseFloat(initialBalanceInput.value) || 15;
                const initialBalanceUnit = initialBalanceUnitSelect ? initialBalanceUnitSelect.value : 'M';
                const initialBalance = this.parseAmount(initialBalanceRaw, initialBalanceUnit);
                const player = {
                    id: Date.now().toString(),
                    name: name,
                    token: this.tokens.find(t => t.id === this.selectedToken),
                    balance: initialBalance,
                    isActive: true
                };

                this.players.push(player);
                this.saveState();
                this.updateUI();

                // Reset form
                nameInput.value = '';
                document.querySelectorAll('.token-option').forEach(o => o.classList.remove('selected'));
                this.selectedToken = null;

                // Disable used token
                this.disableUsedToken(this.selectedToken);
            }

            disableUsedToken(tokenId) {
                const tokenOption = document.querySelector(`[data-token-id="${tokenId}"]`);
                if (tokenOption) {
                    tokenOption.style.opacity = '0.5';
                    tokenOption.style.pointerEvents = 'none';
                }
            }

            parseAmount(amount, unit) {
                switch (unit) {
                    case 'K': return amount * 1000;
                    case 'M': return amount * 1000000;
                    default: return amount;
                }
            }

            formatBalance(amount) {
                if (amount >= 1000000) {
                    const millions = amount / 1000000;
                    // Show 2 decimal places for M unit
                    return millions.toFixed(2) + 'M';
                } else if (amount >= 1000) {
                    const thousands = amount / 1000;
                    // Check if it's a whole number, if so show no decimal places, otherwise show 1 decimal
                    return thousands % 1 === 0 ? thousands.toFixed(0) + 'K' : thousands.toFixed(1) + 'K';
                } else {
                    return amount.toString();
                }
            }

            startGame() {
                if (this.players.length < 2) {
                    alert('At least 2 players required to start the game');
                    return;
                }

                // Update all players' balances to the current starting balance
                const initialBalanceInput = document.getElementById('initialBalance');
                const initialBalanceUnitSelect = document.getElementById('initialBalanceUnit');
                const initialBalanceRaw = parseFloat(initialBalanceInput.value) || 15;
                const initialBalanceUnit = initialBalanceUnitSelect ? initialBalanceUnitSelect.value : 'M';
                const initialBalance = this.parseAmount(initialBalanceRaw, initialBalanceUnit);
                this.players.forEach(player => {
                    player.balance = initialBalance;
                });

                this.saveState();
                this.switchScreen(2);
                alert(`Game started! All players begin with $${this.formatBalance(initialBalance)}.`);
            }

            resetPlayers() {
                if (confirm('Are you sure you want to reset all players? This will remove all players and reset the game.')) {
                    this.players = [];
                    this.transactions = [];
                    this.saveState();
                    this.updateUI();

                    // Reset token selection
                    this.selectedToken = null;
                    document.querySelectorAll('.token-option').forEach(o => {
                        o.classList.remove('selected');
                        o.style.opacity = '1';
                        o.style.pointerEvents = 'auto';
                    });

                    alert('All players reset successfully!');
                }
            }

            updateTransactionForm() {
                const fromPlayerGroup = document.getElementById('fromPlayerGroup');
                const toPlayerGroup = document.getElementById('toPlayerGroup');
                const toManyGroup = document.getElementById('toManyGroup');
                const fromManyGroup = document.getElementById('fromManyGroup');
                const adjustPlayerGroup = document.getElementById('adjustPlayerGroup');
                const adjustTypeGroup = document.getElementById('adjustTypeGroup');
                const fromPlayer = document.getElementById('fromPlayer');
                const toPlayer = document.getElementById('toPlayer');

                // Hide all optional groups first
                fromPlayerGroup.style.display = 'none';
                toPlayerGroup.style.display = 'none';
                toManyGroup.style.display = 'none';
                fromManyGroup.style.display = 'none';
                adjustPlayerGroup.style.display = 'none';
                adjustTypeGroup.style.display = 'none';

                // Update player selects
                this.updatePlayerSelects();

                switch (this.transactionType) {
                    case 'one-to-one':
                        fromPlayerGroup.style.display = 'block';
                        toPlayerGroup.style.display = 'block';
                        break;
                    case 'one-to-many':
                        fromPlayerGroup.style.display = 'block';
                        toManyGroup.style.display = 'block';
                        this.renderToManyCheckboxes();
                        break;
                    case 'many-to-one':
                        fromManyGroup.style.display = 'block';
                        toPlayerGroup.style.display = 'block';
                        this.renderFromManyCheckboxes();
                        break;
                    case 'adjust':
                        adjustPlayerGroup.style.display = 'block';
                        adjustTypeGroup.style.display = 'block';
                        this.updateAdjustPlayerSelect();
                        break;
                }
            }

            updatePlayerSelects() {
                const fromSelect = document.getElementById('fromPlayer');
                const toSelect = document.getElementById('toPlayer');

                const playerOptions = this.players.map(p =>
                    `<option value="${p.id}">${p.name}</option>`
                ).join('');

                fromSelect.innerHTML = '<option value="">Select player</option>' + playerOptions;
                toSelect.innerHTML = '<option value="">Select player</option>' + playerOptions;
            }

            renderToManyCheckboxes() {
                const container = document.getElementById('toManyCheckboxes');
                container.innerHTML = this.players.map(p => `
                    <label style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" value="${p.id}" style="margin-right: 8px;">
                        <span>${p.name} (${p.token.name})</span>
                    </label>
                `).join('');
            }

            renderFromManyCheckboxes() {
                const container = document.getElementById('fromManyCheckboxes');
                container.innerHTML = this.players.map(p => `
                    <label style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" value="${p.id}" style="margin-right: 8px;">
                        <span>${p.name} (${p.token.name})</span>
                    </label>
                `).join('');
            }

            updateAdjustPlayerSelect() {
                const adjustSelect = document.getElementById('adjustPlayer');
                const playerOptions = this.players.map(p =>
                    `<option value="${p.id}">${p.name}</option>`
                ).join('');
                adjustSelect.innerHTML = '<option value="">Select player</option>' + playerOptions;
            }

            addTransaction() {
                const amountInput = document.getElementById('amount');
                const amountUnitSelect = document.getElementById('amountUnit');
                const rawAmount = parseFloat(amountInput.value);
                const amountUnit = amountUnitSelect ? amountUnitSelect.value : 'K';
                const amount = this.parseAmount(rawAmount, amountUnit);
                const description = document.getElementById('description').value.trim();

                if (isNaN(amount) || amount <= 0) {
                    alert('Please enter a valid amount');
                    return;
                }

                let from = [], to = [];

                switch (this.transactionType) {
                    case 'one-to-one':
                        const fromSelect = document.getElementById('fromPlayer');
                        const toSelect = document.getElementById('toPlayer');

                        if (!fromSelect.value || !toSelect.value) {
                            alert('Please select both players');
                            return;
                        }

                        if (fromSelect.value === toSelect.value) {
                            alert('Cannot transfer to the same player');
                            return;
                        }

                        from = [fromSelect.value];
                        to = [toSelect.value];
                        break;

                    case 'one-to-many':
                        const fromManySelect = document.getElementById('fromPlayer');
                        const toManyCheckboxes = document.querySelectorAll('#toManyCheckboxes input:checked');

                        if (!fromManySelect.value || toManyCheckboxes.length === 0) {
                            alert('Please select sender and at least one recipient');
                            return;
                        }

                        if (toManyCheckboxes.length === 1 && toManyCheckboxes[0].value === fromManySelect.value) {
                            alert('Cannot transfer to the same player');
                            return;
                        }

                        from = [fromManySelect.value];
                        to = Array.from(toManyCheckboxes).map(cb => cb.value);
                        break;

                    case 'many-to-one':
                        const fromManyCheckboxes = document.querySelectorAll('#fromManyCheckboxes input:checked');
                        const toManySelect = document.getElementById('toPlayer');

                        if (fromManyCheckboxes.length === 0 || !toManySelect.value) {
                            alert('Please select at least one payer and a recipient');
                            return;
                        }

                        from = Array.from(fromManyCheckboxes).map(cb => cb.value);
                        to = [toManySelect.value];
                        break;

                    case 'adjust':
                        const adjustPlayer = document.getElementById('adjustPlayer');
                        const adjustType = document.getElementById('adjustType');

                        if (!adjustPlayer.value) {
                            alert('Please select a player to adjust');
                            return;
                        }

                        if (adjustType.value === 'add') {
                            from = ['bank'];
                            to = [adjustPlayer.value];
                        } else {
                            from = [adjustPlayer.value];
                            to = ['bank'];
                        }
                        break;
                }

                // Process transaction
                const transaction = {
                    id: Date.now().toString(),
                    type: this.transactionType,
                    from: from,
                    to: to,
                    amount: amount,
                    description: description || 'Transaction',
                    timestamp: new Date().toISOString()
                };

                // Update balances
                this.processTransaction(transaction);
                this.transactions.push(transaction);
                this.saveState();
                this.updateUI();

                // Reset form
                document.getElementById('amount').value = '';
                document.getElementById('description').value = '';
                document.getElementById('fromPlayer').value = '';
                document.getElementById('toPlayer').value = '';
                document.getElementById('adjustPlayer').value = '';
                document.getElementById('adjustType').value = 'add';
                document.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
            }

            processTransaction(transaction) {
                const amountPerPerson = transaction.type === 'one-to-many'
                    ? transaction.amount / transaction.to.length
                    : transaction.type === 'many-to-one'
                    ? transaction.amount / transaction.from.length
                    : transaction.amount;

                // Deduct from senders
                transaction.from.forEach(playerId => {
                    if (playerId === 'bank') return; // Bank doesn't have balance
                    const player = this.players.find(p => p.id === playerId);
                    if (player) {
                        player.balance -= amountPerPerson;
                    }
                });

                // Add to recipients
                transaction.to.forEach(playerId => {
                    if (playerId === 'bank') return; // Bank doesn't have balance
                    const player = this.players.find(p => p.id === playerId);
                    if (player) {
                        player.balance += amountPerPerson;
                    }
                });
            }

            updateUI() {
                this.updatePlayerList();
                this.updateBalances();
                this.updateTransactionHistory();
                this.updateNavigationDots();
            }

            updatePlayerList() {
                const container = document.getElementById('playersContainer');
                const startBtn = document.getElementById('startGameBtn');

                if (this.players.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-secondary);">No players added yet</p>';
                    startBtn.style.display = 'none';
                } else {
                    container.innerHTML = this.players.map(player => `
                        <div class="player-item" style="position: relative; align-items: center;">
                            <div class="player-token">${player.token.svg}</div>
                            <div class="player-info" style="flex: 1;">
                                <div class="player-name">${player.name}</div>
                                <div class="player-balance">$${this.formatBalance(player.balance)}</div>
                            </div>
                            <button class="delete-player-btn" onclick="game.deletePlayer('${player.id}')" title="Delete player">
                                üóëÔ∏è
                            </button>
                        </div>
                    `).join('');

                    startBtn.style.display = this.players.length >= 2 ? 'block' : 'none';
                }
            }

            updateBalances() {
                const container = document.getElementById('currentBalances');

                if (this.players.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-secondary);">No players</p>';
                } else {
                    container.innerHTML = this.players.map(player => {
                        const balanceClass = player.balance >= 0 ? 'balance-positive' : 'balance-negative';
                        return `
                            <div class="player-item">
                                <div class="player-token">${player.token.svg}</div>
                                <div class="player-info">
                                    <div class="player-name">${player.name}</div>
                                    <div class="player-balance ${balanceClass}">$${this.formatBalance(player.balance)}</div>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            }

            updateTransactionHistory() {
                const container = document.getElementById('historyList');

                if (this.transactions.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-secondary);">No transactions yet</p>';
                } else {
                    const sortedTransactions = [...this.transactions].reverse();
                    container.innerHTML = sortedTransactions.map(transaction => {
                        const date = new Date(transaction.timestamp);
                        const timeStr = date.toLocaleString();

                        const getDisplayName = (id) => {
                            if (id === 'bank') return 'üè¶ Bank';
                            const player = this.players.find(p => p.id === id);
                            return player ? player.name : 'Unknown';
                        };

                        const fromNames = transaction.from.map(getDisplayName).join(', ');
                        const toNames = transaction.to.map(getDisplayName).join(', ');

                        let transactionText = transaction.type === 'adjust'
                            ? `<strong>${fromNames}</strong> ${fromNames.includes('Bank') ? '‚Üí' : '‚Üí Bank'} <strong>${toNames}</strong>`
                            : `<strong>${fromNames}</strong> ‚Üí <strong>${toNames}</strong>`;

                        return `
                            <div class="history-item">
                                <div class="history-time">${timeStr}</div>
                                <div>${transactionText}</div>
                                <div>$${this.formatBalance(transaction.amount)} - ${transaction.description}</div>
                            </div>
                        `;
                    }).join('');
                }
            }

            updateNavigationDots() {
                document.querySelectorAll('.nav-dot').forEach(dot => {
                    dot.classList.remove('active');
                    if (parseInt(dot.dataset.screen) === this.currentScreen) {
                        dot.classList.add('active');
                    }
                });
            }

            checkOnlineStatus() {
                const indicator = document.getElementById('offlineIndicator');
                if (navigator.onLine) {
                    indicator.classList.remove('show');
                } else {
                    indicator.classList.add('show');
                }
            }

            // Data persistence
            saveState() {
                const state = {
                    players: this.players,
                    transactions: this.transactions,
                    lastModified: new Date().toISOString()
                };
                localStorage.setItem('monopolyGameState', JSON.stringify(state));
            }

            loadState() {
                const savedState = localStorage.getItem('monopolyGameState');
                if (savedState) {
                    try {
                        const state = JSON.parse(savedState);
                        this.players = state.players || [];
                        this.transactions = state.transactions || [];

                        // Reconstruct token objects
                        this.players.forEach(player => {
                            if (typeof player.token === 'string') {
                                player.token = this.tokens.find(t => t.id === player.token) || this.tokens[0];
                            }
                        });
                    } catch (e) {
                        console.error('Error loading state:', e);
                    }
                }
            }

            exportData() {
                const data = {
                    players: this.players,
                    transactions: this.transactions,
                    exportDate: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `monopoly-game-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            importData(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        this.players = data.players || [];
                        this.transactions = data.transactions || [];

                        // Reconstruct token objects
                        this.players.forEach(player => {
                            if (typeof player.token === 'string') {
                                player.token = this.tokens.find(t => t.id === player.token) || this.tokens[0];
                            }
                        });

                        this.saveState();
                        this.updateUI();
                        this.switchScreen(1);
                        alert('Game data imported successfully!');
                    } catch (error) {
                        alert('Error importing file. Please check the file format.');
                    }
                };
                reader.readAsText(file);
                event.target.value = ''; // Reset file input
            }

            resetPlayers() {
                if (confirm('Are you sure you want to reset all players? This will remove all players and reset the game.')) {
                    this.players = [];
                    this.transactions = [];
                    this.saveState();
                    this.updateUI();

                    // Reset token selection
                    this.selectedToken = null;
                    document.querySelectorAll('.token-option').forEach(o => {
                        o.classList.remove('selected');
                        o.style.opacity = '1';
                        o.style.pointerEvents = 'auto';
                    });

                    alert('All players reset successfully!');
                }
            }

            setNewInitialBalance() {
                const newBalanceInput = document.getElementById('newInitialBalance');
                const newBalanceUnitSelect = document.getElementById('newInitialBalanceUnit');
                const newBalanceRaw = parseFloat(newBalanceInput.value) || 15;
                const newBalanceUnit = newBalanceUnitSelect ? newBalanceUnitSelect.value : 'M';
                const newBalance = this.parseAmount(newBalanceRaw, newBalanceUnit);
                if (isNaN(newBalance) || newBalance < 0) {
                    alert('Please enter a valid amount');
                    return;
                }

                // Update the initial balance input on the setup screen
                document.getElementById('initialBalance').value = newBalanceRaw;
                if (newBalanceUnitSelect) {
                    newBalanceUnitSelect.value = newBalanceUnit;
                }

                if (this.players.length > 0) {
                    if (confirm(`This will reset all players and set new starting balance to $${this.formatBalance(newBalance)}. Continue?`)) {
                        this.players = [];
                        this.transactions = [];
                        this.saveState();
                        this.updateUI();
                        alert(`Starting balance set to $${this.formatBalance(newBalance)}. Add new players to begin!`);
                    }
                } else {
                    alert(`Starting balance set to $${this.formatBalance(newBalance)}. Add players to begin!`);
                }
            }

            deletePlayer(playerId) {
                const player = this.players.find(p => p.id === playerId);
                if (!player) return;

                if (confirm(`Are you sure you want to remove ${player.name}?`)) {
                    this.players = this.players.filter(p => p.id !== playerId);
                    this.saveState();
                    this.updateUI();
                    this.reenableToken(player.token.id);
                }
            }

            reenableToken(tokenId) {
                const tokenOption = document.querySelector(`[data-token-id="${tokenId}"]`);
                if (tokenOption) {
                    tokenOption.style.opacity = '1';
                    tokenOption.style.pointerEvents = 'auto';
                }
            }

            restartGame() {
                const initialBalanceInput = document.getElementById('initialBalance');
                const initialBalanceUnitSelect = document.getElementById('initialBalanceUnit');
                const initialBalanceRaw = parseFloat(initialBalanceInput.value) || 15;
                const initialBalanceUnit = initialBalanceUnitSelect ? initialBalanceUnitSelect.value : 'M';
                const initialBalance = this.parseAmount(initialBalanceRaw, initialBalanceUnit);
                if (confirm(`Are you sure you want to restart the game? This will reset all player balances to $${this.formatBalance(initialBalance)}.`)) {
                    this.players.forEach(player => {
                        player.balance = initialBalance;
                    });
                    this.transactions = [];
                    this.saveState();
                    this.updateUI();
                    alert(`Game restarted! All balances reset to $${this.formatBalance(initialBalance)}.`);
                }
            }

            endGame() {
                if (confirm('Are you sure you want to end the game and return to setup?')) {
                    this.switchScreen(1);
                    alert('Game ended! You can now modify players or start a new game.');
                }
            }

            resetGame() {
                if (confirm('Are you sure you want to reset the complete game? This will delete all players, transactions, and reset starting balance to $15M.')) {
                    this.players = [];
                    this.transactions = [];
                    document.getElementById('initialBalance').value = 15;
                    document.getElementById('initialBalanceUnit').value = 'M';
                    document.getElementById('newInitialBalance').value = 15;
                    document.getElementById('newInitialBalanceUnit').value = 'M';
                    this.saveState();
                    this.updateUI();
                    this.switchScreen(1);

                    // Reset token selection
                    this.selectedToken = null;
                    document.querySelectorAll('.token-option').forEach(o => {
                        o.classList.remove('selected');
                        o.style.opacity = '1';
                        o.style.pointerEvents = 'auto';
                    });

                    alert('Complete game reset successfully!');
                }
            }

            // Voice Control System
            initializeVoiceControl() {
                // Check if speech recognition is supported
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.warn('Speech recognition not supported');
                    document.getElementById('voiceBtn').style.display = 'none';
                    return;
                }

                this.recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                this.setupVoiceRecognition();
                this.setupVoiceUI();
            }

            setupVoiceRecognition() {
                this.recognition.lang = 'zh-CN';
                this.recognition.continuous = false;
                this.recognition.interimResults = true;
                this.recognition.maxAlternatives = 3; // Increase alternatives for better matching

                this.recognition.onresult = (event) => {
                    const result = event.results[event.results.length - 1];

                    if (result.isFinal) {
                        // Try all alternatives for better recognition
                        for (let i = 0; i < result.length; i++) {
                            const transcript = result[i].transcript;
                            console.log(`Voice alternative ${i}: "${transcript}"`);

                            const command = this.parseVoiceCommand(transcript);
                            if (command) {
                                this.processVoiceCommand(transcript, command);
                                return;
                            }
                        }

                        // If no alternative worked, try with the first result
                        this.processVoiceCommand(result[0].transcript);
                    } else {
                        this.showInterimResult(result[0].transcript);
                    }
                };

                this.recognition.onerror = (event) => {
                    console.error('Voice recognition error:', event.error);
                    let errorMsg = 'ËØÜÂà´Â§±Ë¥•';
                    switch (event.error) {
                        case 'no-speech':
                            errorMsg = 'Ê≤°ÊúâÊ£ÄÊµãÂà∞ËØ≠Èü≥';
                            break;
                        case 'audio-capture':
                            errorMsg = 'Êó†Ê≥ïËÆøÈóÆÈ∫¶ÂÖãÈ£é';
                            break;
                        case 'not-allowed':
                            errorMsg = 'È∫¶ÂÖãÈ£éÊùÉÈôêË¢´ÊãíÁªù';
                            break;
                        case 'network':
                            errorMsg = 'ÁΩëÁªúÈîôËØØ';
                            break;
                    }
                    this.showVoiceError(errorMsg);
                };

                this.recognition.onend = () => {
                    this.stopVoiceListening();
                };
            }

            setupVoiceUI() {
                const voiceBtn = document.getElementById('voiceBtn');
                const languageMode = document.getElementById('voiceLanguageMode');

                // Language mode change handler
                languageMode.addEventListener('change', () => {
                    this.updateVoiceLanguage();
                });

                // Mouse events for desktop
                voiceBtn.addEventListener('mousedown', () => this.startVoiceListening());
                voiceBtn.addEventListener('mouseup', () => this.stopVoiceListening());
                voiceBtn.addEventListener('mouseleave', () => this.stopVoiceListening());

                // Touch events for mobile
                voiceBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startVoiceListening();
                });
                voiceBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.stopVoiceListening();
                });
                voiceBtn.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.stopVoiceListening();
                });

                // Confirmation dialog buttons
                document.getElementById('voiceConfirmBtn').addEventListener('click', () => {
                    this.executeVoiceCommand();
                });

                document.getElementById('voiceCancelBtn').addEventListener('click', () => {
                    this.hideVoiceConfirmDialog();
                });
            }

            updateVoiceLanguage() {
                const languageMode = document.getElementById('voiceLanguageMode').value;

                switch (languageMode) {
                    case 'zh-CN':
                        this.recognition.lang = 'zh-CN';
                        this.showInterimResult('Â∑≤ÂàáÊç¢Âà∞‰∏≠ÊñáËØÜÂà´Ê®°Âºè');
                        break;
                    case 'en-US':
                        this.recognition.lang = 'en-US';
                        this.showInterimResult('Â∑≤ÂàáÊç¢Âà∞Ëã±ÊñáËØÜÂà´Ê®°Âºè');
                        break;
                    case 'auto':
                        this.recognition.lang = 'zh-CN'; // Default to Chinese, but patterns handle both
                        this.showInterimResult('Ëá™Âä®Ê£ÄÊµãÊ®°ÂºèÔºàÊé®ËçêÁî®‰∫é‰∏≠Ëã±Ê∑∑ÂêàÔºâ');
                        break;
                }

                setTimeout(() => {
                    document.getElementById('voiceResult').innerHTML =
                        '<span style="color: rgba(255,255,255,0.6);">Êåâ‰ΩèÊåâÈíÆËØ¥Âá∫ËΩ¨Ë¥¶ÂëΩ‰ª§</span>';
                }, 2000);
            }

            startVoiceListening() {
                if (!this.recognition) return;

                try {
                    this.recognition.start();
                    document.getElementById('voiceBtn').classList.add('listening');
                    document.querySelector('#voiceBtn .voice-text').textContent = 'Ê≠£Âú®Âê¨Âèñ...';
                    this.showInterimResult('Ê≠£Âú®Âê¨ÂèñÊÇ®ÁöÑÂëΩ‰ª§...');
                } catch (error) {
                    console.error('Failed to start recognition:', error);
                }
            }

            stopVoiceListening() {
                if (!this.recognition) return;

                try {
                    this.recognition.stop();
                } catch (error) {
                    // Already stopped
                }

                document.getElementById('voiceBtn').classList.remove('listening');
                document.querySelector('#voiceBtn .voice-text').textContent = 'Êåâ‰ΩèËØ¥ËØù';
            }

            showInterimResult(text) {
                document.getElementById('voiceResult').innerHTML =
                    `<span style="color: rgba(255,255,255,0.8);">üé§ ${text}</span>`;
            }

            showVoiceError(error) {
                document.getElementById('voiceResult').innerHTML =
                    `<span style="color: #ff6b6b;">‚ùå ${error}</span>`;
                setTimeout(() => {
                    document.getElementById('voiceResult').innerHTML =
                        '<span style="color: rgba(255,255,255,0.6);">Êåâ‰ΩèÊåâÈíÆËØ¥Âá∫ËΩ¨Ë¥¶ÂëΩ‰ª§</span>';
                }, 3000);
            }

            async processVoiceCommand(transcript, preParsedCommand = null) {
                const llmMode = document.getElementById('llmCorrectionMode').value;

                // First try without LLM
                const command = preParsedCommand || this.parseVoiceCommand(transcript);

                if (command) {
                    // Validate that players exist
                    const validationError = this.validateVoiceCommand(command);
                    if (validationError) {
                        this.showVoiceError(validationError);
                        return;
                    }

                    this.pendingVoiceCommand = command;
                    this.showVoiceConfirmDialog(command);
                    return;
                }

                // If direct parsing failed and LLM is enabled, try LLM correction
                if (llmMode === 'enabled' && !preParsedCommand) {
                    this.showInterimResult('ü§ñ AIÊ≠£Âú®Á∫†Ê≠£ËØ≠Èü≥ËØÜÂà´...');

                    try {
                        const correctedTranscript = await this.correctWithLLM(transcript);
                        this.showInterimResult(`AIÁ∫†Ê≠£: "${correctedTranscript}"`);

                        // Try parsing the corrected version
                        const correctedCommand = this.parseVoiceCommand(correctedTranscript);
                        if (correctedCommand) {
                            const validationError = this.validateVoiceCommand(correctedCommand);
                            if (validationError) {
                                this.showVoiceError(validationError);
                                return;
                            }

                            this.pendingVoiceCommand = correctedCommand;
                            this.showVoiceConfirmDialog(correctedCommand);
                            return;
                        }
                    } catch (error) {
                        console.error('LLM correction failed:', error);
                        this.showInterimResult('AIÁ∫†ÈîôÂ§±Ë¥•Ôºå‰ΩøÁî®ÂéüÂßãËØÜÂà´ÁªìÊûú');
                    }
                }

                // If all attempts failed, provide helpful feedback
                const feedback = this.generateVoiceFeedback(transcript);
                this.showVoiceError(feedback);
            }

            validateVoiceCommand(command) {
                if (command.type === 'transfer') {
                    const fromPlayer = this.findPlayerByName(command.from);
                    const toPlayer = this.findPlayerByName(command.to);

                    if (!fromPlayer && !toPlayer) {
                        return `Êâæ‰∏çÂà∞Áé©ÂÆ∂: ${command.from} Âíå ${command.to}`;
                    }
                    if (!fromPlayer) {
                        return `Êâæ‰∏çÂà∞Áé©ÂÆ∂: ${command.from}`;
                    }
                    if (!toPlayer) {
                        return `Êâæ‰∏çÂà∞Áé©ÂÆ∂: ${command.to}`;
                    }
                    if (fromPlayer.id === toPlayer.id) {
                        return '‰∏çËÉΩËΩ¨Ë¥¶ÁªôËá™Â∑±';
                    }
                } else if (command.type === 'adjust') {
                    const player = this.findPlayerByName(command.player);
                    if (!player) {
                        return `Êâæ‰∏çÂà∞Áé©ÂÆ∂: ${command.player}`;
                    }
                }

                return null;
            }

            generateVoiceFeedback(transcript) {
                const lowerTranscript = transcript.toLowerCase();

                // Check if it contains player names but wrong pattern
                const knownPlayers = this.players.map(p => p.name.toLowerCase());
                const mentionedPlayers = knownPlayers.filter(name =>
                    lowerTranscript.includes(name)
                );

                if (mentionedPlayers.length > 0) {
                    return `ËØÜÂà´Âà∞Áé©ÂÆ∂: ${mentionedPlayers.join(', ')}ÔºåËØ∑Ê£ÄÊü•ÂëΩ‰ª§Ê†ºÂºè`;
                }

                // Check if it has numbers but no clear pattern
                const hasNumbers = /\d+/.test(transcript);
                const hasUnit = /[km]/i.test(transcript);

                if (hasNumbers && hasUnit) {
                    return 'ËØÜÂà´Âà∞ÈáëÈ¢ùÔºåËØ∑Ê£ÄÊü•Áé©ÂÆ∂ÂêçÁß∞ÂíåÂëΩ‰ª§Ê†ºÂºè';
                }

                // Check if it's in English but we're expecting Chinese
                const englishWords = transcript.match(/[a-zA-Z]+/g);
                const chineseWords = transcript.match(/[\u4e00-\u9fa5]+/g);

                if (englishWords && englishWords.length > 0 && !chineseWords) {
                    return 'ËØ∑‰ΩøÁî®‰∏≠ÊñáÂëΩ‰ª§Ê†ºÂºèÔºåÂ¶ÇÔºö"EasonËΩ¨ÁªôHoly 100K"';
                }

                return 'Êó†Ê≥ïËØÜÂà´ÂëΩ‰ª§ÔºåËØ∑ÂèÇËÄÉÁ§∫‰æãÊ†ºÂºè';
            }

            parseVoiceCommand(text) {
                // Pre-process text to handle common recognition errors
                const cleanedText = this.preprocessVoiceText(text);
                console.log(`Original: "${text}" -> Cleaned: "${cleanedText}"`);

                // Chinese number mapping
                const chineseNumbers = {
                    'Èõ∂': 0, '‰∏Ä': 1, '‰∫å': 2, '‰∏â': 3, 'Âõõ': 4, '‰∫î': 5,
                    'ÂÖ≠': 6, '‰∏É': 7, 'ÂÖ´': 8, '‰πù': 9, 'ÂçÅ': 10,
                    'ÂçÅ‰∏Ä': 11, 'ÂçÅ‰∫å': 12, 'ÂçÅ‰∏â': 13, 'ÂçÅÂõõ': 14, 'ÂçÅ‰∫î': 15,
                    '‰∫åÂçÅ': 20, '‰∏âÂçÅ': 30, 'ÂõõÂçÅ': 40, '‰∫îÂçÅ': 50,
                    'ÂÖ≠ÂçÅ': 60, '‰∏ÉÂçÅ': 70, 'ÂÖ´ÂçÅ': 80, '‰πùÂçÅ': 90,
                    '‰∏ÄÁôæ': 100, '‰∏ÄÁôæ‰∫î': 150, '‰∫åÁôæ': 200, '‰∏âÁôæ': 300,
                    'ÂõõÁôæ': 400, '‰∫îÁôæ': 500, 'ÂÖ≠Áôæ': 600, '‰∏ÉÁôæ': 700,
                    'ÂÖ´Áôæ': 800, '‰πùÁôæ': 900, '‰∏ÄÂçÉ': 1000
                };

                // Helper function to convert Chinese numbers in a string
                const convertChineseNumbers = (str) => {
                    let converted = str;
                    Object.entries(chineseNumbers).forEach(([chinese, arabic]) => {
                        converted = converted.replace(new RegExp(chinese, 'g'), arabic);
                    });
                    return converted;
                };

                // Enhanced patterns for transfer commands
                const transferPatterns = [
                    // Chinese patterns
                    { regex: /(.+?)ËΩ¨Áªô(.+?)(\d+)([KM])/i, type: 'transfer' },
                    { regex: /(.+?)Áªô(.+?)ËΩ¨(\d+)([KM])/i, type: 'transfer' },
                    { regex: /(.+?)ÊîØ‰ªòÁªô(.+?)(\d+)([KM])/i, type: 'transfer' },
                    { regex: /(.+?)ËΩ¨Ë¥¶Áªô(.+?)(\d+)([KM])/i, type: 'transfer' },
                    // Mixed patterns - more flexible
                    { regex: /(.+?)transfer\s*to\s*(.+?)(\d+)([KM])/i, type: 'transfer' },
                    { regex: /(.+?)send\s*to\s*(.+?)(\d+)([KM])/i, type: 'transfer' },
                    { regex: /(.+?)Áªô(.+?)(\d+)([KM])/i, type: 'transfer' }, // Simplified
                    // English patterns
                    { regex: /(.+?)transfer\s*(.+?)\s*(\d+)([KM])/i, type: 'transfer' },
                    { regex: /(.+?)send\s*(.+?)\s*(\d+)([KM])/i, type: 'transfer' }
                ];

                // Enhanced patterns for adjustment commands
                const adjustPatterns = [
                    // Chinese patterns
                    { regex: /Áªô(.+?)Â¢ûÂä†(\d+)([KM])/i, type: 'adjust', adjustType: 'add' },
                    { regex: /Áªô(.+?)Âä†‰∏ä(\d+)([KM])/i, type: 'adjust', adjustType: 'add' },
                    { regex: /Áªô(.+?)Ê∑ªÂä†(\d+)([KM])/i, type: 'adjust', adjustType: 'add' },
                    { regex: /‰ªé(.+?)ÂáèÂ∞ë(\d+)([KM])/i, type: 'adjust', adjustType: 'subtract' },
                    { regex: /‰ªé(.+?)Êâ£Èô§(\d+)([KM])/i, type: 'adjust', adjustType: 'subtract' },
                    { regex: /‰ªé(.+?)ÂáèÂéª(\d+)([KM])/i, type: 'adjust', adjustType: 'subtract' },
                    // Mixed/English patterns
                    { regex: /(.+?)add\s*(\d+)([KM])/i, type: 'adjust', adjustType: 'add' },
                    { regex: /(.+?)give\s*(\d+)([KM])/i, type: 'adjust', adjustType: 'add' },
                    { regex: /(.+?)subtract\s*(\d+)([KM])/i, type: 'adjust', adjustType: 'subtract' },
                    { regex: /(.+?)take\s*(\d+)([KM])/i, type: 'adjust', adjustType: 'subtract' }
                ];

                // Try to match transfer patterns
                for (let pattern of transferPatterns) {
                    const match = cleanedText.match(pattern.regex);
                    if (match) {
                        const convertedNumber = convertChineseNumbers(match[3]);
                        const amount = parseInt(convertedNumber);

                        if (isNaN(amount) || amount <= 0) continue;

                        return {
                            type: 'transfer',
                            from: this.cleanPlayerName(match[1].trim()),
                            to: this.cleanPlayerName(match[2].trim()),
                            amount: amount,
                            unit: match[4].toUpperCase(),
                            originalText: text
                        };
                    }
                }

                // Try to match adjustment patterns
                for (let pattern of adjustPatterns) {
                    const match = cleanedText.match(pattern.regex);
                    if (match) {
                        const convertedNumber = convertChineseNumbers(match[2]);
                        const amount = parseInt(convertedNumber);

                        if (isNaN(amount) || amount <= 0) continue;

                        return {
                            type: 'adjust',
                            player: this.cleanPlayerName(match[1].trim()),
                            amount: amount,
                            unit: match[3].toUpperCase(),
                            adjustType: pattern.adjustType,
                            originalText: text
                        };
                    }
                }

                return null;
            }

            preprocessVoiceText(text) {
                // Common voice recognition error corrections
                const corrections = {
                    '‰ºäÊ£Æ': 'Eason',
                    'ÈúçÂà©': 'Holy',
                    'ËñáËñáÂÆâ': 'Vivian',
                    'Ë¥æÊñØÊ±Ä': 'Justin',
                    'ÁëûËæõ': 'Resin',
                    '‰∏ÄÊ£Æ': 'Eason',
                    'ÈúçÈáå': 'Holy',
                    'Áª¥Áª¥': 'Vivian',
                    'Ë¥æÊñØ‰∏Å': 'Justin',
                    'ÁëûÊ£Æ': 'Resin'
                };

                let cleaned = text.toLowerCase();

                // Apply corrections
                Object.entries(corrections).forEach(([wrong, correct]) => {
                    cleaned = cleaned.replace(new RegExp(wrong, 'gi'), correct);
                });

                // Remove filler words and common recognition artifacts
                const fillerWords = ['ÂëÉ', 'ÂóØ', 'ÈÇ£‰∏™', 'Ëøô‰∏™', 'Â∞±ÊòØ', 'ÊàëË¶Å', 'ÊàëÊÉ≥', 'ËØ∑'];
                fillerWords.forEach(word => {
                    cleaned = cleaned.replace(new RegExp(word, 'gi'), '');
                });

                // Normalize spaces
                cleaned = cleaned.replace(/\s+/g, ' ').trim();

                return cleaned;
            }

            cleanPlayerName(name) {
                // Remove common articles and prepositions from names
                return name.replace(/^(a|an|the)\s+/i, '').trim();
            }

            showVoiceConfirmDialog(command) {
                const dialog = document.getElementById('voiceConfirmDialog');
                const textElement = document.getElementById('voiceConfirmText');

                let confirmText = '';
                if (command.type === 'transfer') {
                    confirmText = `${command.from} ËΩ¨Áªô ${command.to}<br><strong>${command.amount}${command.unit}</strong>`;
                } else if (command.type === 'adjust') {
                    const action = command.adjustType === 'add' ? 'Â¢ûÂä†' : 'ÂáèÂ∞ë';
                    confirmText = `${command.player} ${action}<br><strong>${command.amount}${command.unit}</strong>`;
                }

                textElement.innerHTML = confirmText;
                dialog.classList.remove('hidden');
            }

            hideVoiceConfirmDialog() {
                document.getElementById('voiceConfirmDialog').classList.add('hidden');
                this.pendingVoiceCommand = null;
            }

            executeVoiceCommand() {
                if (!this.pendingVoiceCommand) return;

                const command = this.pendingVoiceCommand;

                try {
                    if (command.type === 'transfer') {
                        this.executeVoiceTransfer(command);
                    } else if (command.type === 'adjust') {
                        this.executeVoiceAdjust(command);
                    }

                    this.showVoiceSuccess('ÂëΩ‰ª§ÊâßË°åÊàêÂäüÔºÅ');
                } catch (error) {
                    console.error('Voice command execution error:', error);
                    this.showVoiceError('ÂëΩ‰ª§ÊâßË°åÂ§±Ë¥•');
                }

                this.hideVoiceConfirmDialog();
            }

            executeVoiceTransfer(command) {
                const fromPlayer = this.findPlayerByName(command.from);
                const toPlayer = this.findPlayerByName(command.to);

                if (!fromPlayer || !toPlayer) {
                    throw new Error('Player not found');
                }

                const amount = this.parseAmount(command.amount, command.unit);

                const transaction = {
                    id: Date.now().toString(),
                    type: 'one-to-one',
                    from: [fromPlayer.id],
                    to: [toPlayer.id],
                    amount: amount,
                    description: `ËØ≠Èü≥ËΩ¨Ë¥¶: ${command.originalText}`,
                    timestamp: new Date().toISOString()
                };

                this.processTransaction(transaction);
                this.transactions.push(transaction);
                this.saveState();
                this.updateUI();
            }

            executeVoiceAdjust(command) {
                const player = this.findPlayerByName(command.player);

                if (!player) {
                    throw new Error('Player not found');
                }

                const amount = this.parseAmount(command.amount, command.unit);

                const transaction = {
                    id: Date.now().toString(),
                    type: 'adjust',
                    from: command.adjustType === 'add' ? ['bank'] : [player.id],
                    to: command.adjustType === 'add' ? [player.id] : ['bank'],
                    amount: amount,
                    description: `ËØ≠Èü≥Ë∞ÉÊï¥: ${command.originalText}`,
                    timestamp: new Date().toISOString()
                };

                this.processTransaction(transaction);
                this.transactions.push(transaction);
                this.saveState();
                this.updateUI();
            }

            findPlayerByName(name) {
                const normalizedName = name.toLowerCase().trim();

                // Try exact match first
                let player = this.players.find(player =>
                    player.name.toLowerCase().trim() === normalizedName
                );

                if (player) return player;

                // Try partial match for English names (e.g., "Alice" matches "Alice Smith")
                player = this.players.find(player =>
                    player.name.toLowerCase().includes(normalizedName) ||
                    normalizedName.includes(player.name.toLowerCase())
                );

                if (player) return player;

                // Try phonetic matching for common English name variations
                const nameVariations = this.getNameVariations(normalizedName);
                for (let variation of nameVariations) {
                    player = this.players.find(p =>
                        p.name.toLowerCase().trim() === variation
                    );
                    if (player) return player;
                }

                return null;
            }

            getNameVariations(name) {
                const variations = [name];

                // Common English name variations
                const commonVariations = {
                    'alice': ['alice', 'alis', 'alyce'],
                    'bob': ['bob', 'bobb', 'robert'],
                    'charlie': ['charlie', 'charles', 'charley'],
                    'david': ['david', 'dave', 'davey'],
                    'emma': ['emma', 'em', 'emmy'],
                    'frank': ['frank', 'frankie', 'francis'],
                    'grace': ['grace', 'gracie'],
                    'henry': ['henry', 'hank', 'harry'],
                    'ivy': ['ivy', 'ivey'],
                    'jack': ['jack', 'john', 'johnny'],
                    'karen': ['karen', 'kari'],
                    'lucy': ['lucy', 'lucie', 'louise'],
                    'mike': ['mike', 'michael', 'micky'],
                    'nancy': ['nancy', 'nance'],
                    'oliver': ['oliver', 'olive', 'ollie'],
                    'peter': ['peter', 'pete', 'petey'],
                    'quinn': ['quinn', 'quin'],
                    'rachel': ['rachel', 'rach', 'ray'],
                    'sarah': ['sarah', 'sara', 'sally'],
                    'tom': ['tom', 'thomas', 'tommy'],
                    'victor': ['victor', 'vic', 'vicky'],
                    'william': ['william', 'will', 'bill', 'billy'],
                    'zoe': ['zoe', 'zoey', 'zooey'],
                    // Custom names for this project
                    'eason': ['eason', 'eeson', 'easonn', 'yison'],
                    'holy': ['holy', 'holly', 'holli', 'holley'],
                    'vivian': ['vivian', 'vivianne', 'vivi', 'viv', 'vivien'],
                    'resin': ['resin', 'resin', 'resenn', 'rezin'],
                    'justin': ['justin', 'justin', 'justen', 'justyn', 'just']
                };

                if (commonVariations[name]) {
                    variations.push(...commonVariations[name]);
                }

                return variations;
            }

            showVoiceSuccess(message) {
                document.getElementById('voiceResult').innerHTML =
                    `<span style="color: #4caf50;">‚úÖ ${message}</span>`;

                setTimeout(() => {
                    document.getElementById('voiceResult').innerHTML =
                        '<span style="color: rgba(255,255,255,0.6);">Êåâ‰ΩèÊåâÈíÆËØ¥Âá∫ËΩ¨Ë¥¶ÂëΩ‰ª§</span>';
                }, 3000);
            }

            // LLM Correction System
            async correctWithLLM(transcript) {
                const players = this.players.map(p => p.name).join(', ');

                const prompt = `‰Ω†ÊòØ‰∏Ä‰∏™ËØ≠Èü≥ËØÜÂà´Á∫†ÈîôÂä©ÊâãÔºå‰∏ìÈó®Á∫†Ê≠£MonopolyÊ∏∏ÊàèËØ≠Èü≥ÂëΩ‰ª§„ÄÇ

ÂΩìÂâçÁé©ÂÆ∂: ${players}

ÂéüÂßãËØ≠Èü≥ËØÜÂà´ÁªìÊûú: "${transcript}"

ËØ∑Á∫†Ê≠£‰ª•‰∏ãÂèØËÉΩÁöÑÈîôËØØ:
1. Ëã±ÊñáÂêçÂèëÈü≥ÈîôËØØ (Â¶Ç: ‰ºäÊ£Æ‚ÜíEason, ÈúçÂà©‚ÜíHoly, ËñáËñáÂÆâ‚ÜíVivian)
2. ‰∏≠Ëã±ÊñáÊ∑∑ÂêàË°®Ëææ
3. Êï∞Â≠óËØÜÂà´ÈîôËØØ
4. ËØ≠Ê≥ïÁªìÊûÑÈóÆÈ¢ò

ÊîØÊåÅÁöÑÂëΩ‰ª§Ê†ºÂºè:
- [Áé©ÂÆ∂A]ËΩ¨Áªô[Áé©ÂÆ∂B][ÈáëÈ¢ù][Âçï‰Ωç] (Â¶Ç: EasonËΩ¨ÁªôHoly 100K, EasonËΩ¨ÁªôHoly 1M)
- Áªô[Áé©ÂÆ∂]Â¢ûÂä†[ÈáëÈ¢ù][Âçï‰Ωç] (Â¶Ç: ÁªôEasonÂ¢ûÂä†100K, ÁªôEasonÂ¢ûÂä† 2M)
- ‰ªé[Áé©ÂÆ∂]ÂáèÂ∞ë[ÈáëÈ¢ù][Âçï‰Ωç] (Â¶Ç: ‰ªéEasonÂáèÂ∞ë100K, ‰ªéEasonÂáèÂ∞ë 1M)
- Áé©ÂÆ∂ÂøÖÈ°ªÊòØÂåπÈÖçÊù•Ëá™‚ÄúÂΩìÂâçÁé©ÂÆ∂‚Äù‰∏≠ÁöÑÂêçÂ≠ó
- Âçï‰ΩçÂøÖÈ°ªÊòØkÊàñËÄÖm, Â§ßÂ∞èÂÜôÈÉΩÂèØ‰ª•,Â¶ÇÊûúÁî®Êà∑ËØ¥‰∫Ü‰∏≠ÊñáÁöÑ‚Äú‰∏ÄÁôæ‰∏á‚ÄúÔºåÈÇ£‰πàÊç¢ÁÆóÊàê "1 M", ÊØîÂ¶ÇÁî®Êà∑ËØ¥‰∫Ü‰∏≠ÊñáÁöÑ ÂçÅ‰∏áÔºå ÈÇ£‰πàÊç¢ÁÆóÊàê "100 k"
- ÈáëÈ¢ùÂøÖÈ°ªÊòØÈòøÊãâ‰ºØÊï∞Â≠óÔºå Â¶Ç 100K, 2MÁ≠âÁ≠â

Âè™ËøîÂõûÁ∫†Ê≠£ÂêéÁöÑÂëΩ‰ª§Ôºå‰∏çË¶ÅËß£Èáä„ÄÇÂ¶ÇÊûúÊó†Ê≥ïÁ∫†Ê≠£ÔºåËøîÂõûÂéüÂßãÊñáÊú¨„ÄÇ`;

                return this.callLLMAPI(prompt);
            }

            async callLLMAPI(prompt) {
                const provider = document.getElementById('llmProvider').value;
                const apiKey = this.getApiKey();

                if (provider === 'mock') {
                    return this.localMockLLM(prompt);
                }

                if (!apiKey) {
                    throw new Error('API key not configured');
                }

                // ‰ΩøÁî®ÊúçÂä°Á´Ø‰ª£ÁêÜAPI
                return this.callViaProxy(prompt, provider, apiKey);
            }

            getApiKey() {
                return localStorage.getItem('llm_api_key') || '';
            }

            setApiKey(key) {
                localStorage.setItem('llm_api_key', key);
            }

            
            async callViaProxy(prompt, provider, apiKey) {
                const response = await fetch('/api/llm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        provider: provider,
                        apiKey: apiKey,
                        prompt: prompt,
                        max_tokens: 100,
                        temperature: 0.1
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || `Proxy API error: ${response.status}`);
                }

                const data = await response.json();
                return data.content || '';
            }

            localMockLLM(prompt) {
                // Local mock LLM for basic corrections when API is unavailable
                return new Promise((resolve) => {
                    setTimeout(() => {
                        // Extract transcript from prompt
                        const transcriptMatch = prompt.match(/ÂéüÂßãËØ≠Èü≥ËØÜÂà´ÁªìÊûú: "([^"]+)"/);
                        if (!transcriptMatch) {
                            resolve('');
                            return;
                        }

                        let corrected = transcriptMatch[1];

                        // Basic name corrections
                        const nameCorrections = {
                            '‰ºäÊ£Æ': 'Eason',
                            '‰∏ÄÊ£Æ': 'Eason',
                            'ÈúçÂà©': 'Holy',
                            'ÈúçÈáå': 'Holy',
                            'ËñáËñáÂÆâ': 'Vivian',
                            'Áª¥Áª¥': 'Vivian',
                            'Ë¥æÊñØÊ±Ä': 'Justin',
                            'Ë¥æÊñØ‰∏Å': 'Justin',
                            'ÁëûËæõ': 'Resin',
                            'ÁëûÊ£Æ': 'Resin'
                        };

                        Object.entries(nameCorrections).forEach(([wrong, correct]) => {
                            corrected = corrected.replace(new RegExp(wrong, 'gi'), correct);
                        });

                        // Common pattern corrections
                        corrected = corrected.replace(/(\w+)\s*Áªô\s*(\w+)\s*(\d+)([KM])/i, '$1ËΩ¨Áªô$2$3$4');
                        corrected = corrected.replace(/(\w+)\s*ËΩ¨Ë¥¶Áªô\s*(\w+)\s*(\d+)([KM])/i, '$1ËΩ¨Áªô$2$3$4');

                        resolve(corrected);
                    }, 300); // Simulate API delay
                });
            }

            
            async checkLLMStatus() {
                const provider = document.getElementById('llmProvider').value;
                const apiKey = this.getApiKey();

                if (provider === 'mock') {
                    this.updateLLMStatus('Êú¨Âú∞Ê®°Êãü', '#4caf50');
                    return;
                }

                if (!apiKey) {
                    this.updateLLMStatus('Êú™ÈÖçÁΩÆÂØÜÈí•', '#ff9800');
                    return;
                }

                try {
                    // Simple health check - try a minimal API call
                    const testPrompt = 'ÂéüÂßãËØ≠Èü≥ËØÜÂà´ÁªìÊûú: "ÊµãËØï"\n\nËØ∑ËøîÂõû"ÊµãËØï"';
                    await this.callLLMAPI(testPrompt);
                    this.updateLLMStatus('Â∑≤ËøûÊé•', '#4caf50');
                } catch (error) {
                    this.updateLLMStatus('ËøûÊé•Â§±Ë¥•', '#f44336');
                    console.log('LLM not available:', error.message);
                }
            }

            setupLLMIntegration() {
                // Setup LLM provider selection
                document.getElementById('llmProvider').addEventListener('change', () => {
                    this.updateApiKeyVisibility();
                    this.checkLLMStatus();
                });

                // Setup API key input
                document.getElementById('llmApiKey').addEventListener('input', (e) => {
                    this.setApiKey(e.target.value);
                    this.checkLLMStatus();
                });

                // Setup test button
                document.getElementById('testLlmBtn').addEventListener('click', () => {
                    this.testLLMConnection();
                });

                // Update status when LLM mode changes
                document.getElementById('llmCorrectionMode').addEventListener('change', (e) => {
                    if (e.target.value === 'enabled') {
                        this.checkLLMStatus();
                    }
                });

                // Initialize UI
                this.updateApiKeyVisibility();
                this.checkLLMStatus();
            }

            updateApiKeyVisibility() {
                const provider = document.getElementById('llmProvider').value;
                const apiKeySection = document.getElementById('apiKeySection');
                const apiKeyInput = document.getElementById('llmApiKey');

                if (provider === 'mock') {
                    apiKeySection.style.display = 'none';
                } else {
                    apiKeySection.style.display = 'block';
                    // Load saved API key
                    apiKeyInput.value = this.getApiKey();
                }
            }

            async testLLMConnection() {
                const testBtn = document.getElementById('testLlmBtn');
                const originalText = testBtn.textContent;

                testBtn.textContent = 'ÊµãËØï‰∏≠...';
                testBtn.disabled = true;

                try {
                    const testPrompt = 'ÂéüÂßãËØ≠Èü≥ËØÜÂà´ÁªìÊûú: "ÊµãËØïÊñáÊú¨"\n\nËØ∑ËøîÂõû"ÊµãËØïÊñáÊú¨"';
                    const result = await this.callLLMAPI(testPrompt);

                    if (result && result.trim()) {
                        testBtn.textContent = '‚úÖ ËøûÊé•ÊàêÂäü';
                        testBtn.style.background = 'rgba(76, 175, 80, 0.3)';
                        this.updateLLMStatus('Â∑≤ËøûÊé•', '#4caf50');
                    } else {
                        throw new Error('Empty response');
                    }
                } catch (error) {
                    testBtn.textContent = '‚ùå ËøûÊé•Â§±Ë¥•';
                    testBtn.style.background = 'rgba(244, 67, 54, 0.3)';
                    this.updateLLMStatus('ËøûÊé•Â§±Ë¥•', '#f44336');
                    console.error('LLM test failed:', error);
                }

                setTimeout(() => {
                    testBtn.textContent = originalText;
                    testBtn.style.background = 'rgba(255,255,255,0.2)';
                    testBtn.disabled = false;
                }, 3000);
            }

            updateLLMStatus(status, color) {
                const statusElement = document.getElementById('llmStatus');
                statusElement.textContent = `‚óè ${status}`;
                statusElement.style.color = color;
            }
        }

        // Register Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch((error) => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }

        // Initialize the game when DOM is ready
        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new MonopolyGame();
        });
    </script>
</body>
</html>